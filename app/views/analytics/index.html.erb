<div class="container-fluid py-4">
  <!-- Theme Styles -->
  <style>
    :root {
      --chart-text-color: #333333;
    }
    
    /* Theme Styles */
    
    body.theme-dark .text-muted {
      color: #a0aec0 !important;
    }
    


        /* Dark Theme */
    body.theme-dark {
      background-color: #1e272e; /* Darker background for better contrast */
      color: #dcdde1; /* Light gray text for readability */
    }
    
    body.theme-dark .card {
      background-color: #2f3640; /* Slightly lighter card background */
      border-color: #353b48; /* Subtle border for cards */
      color: #dcdde1; /* Light gray text for readability */
    }

    body.theme-dark .card-header {
      background-color: #353b48; /* Dark gray header background */
      color: #f5f6fa; /* White text for better contrast */
      border-bottom: 1px solid #444; /* Subtle border for separation */
    }
    
    body.theme-dark .text-muted {
      color: #a4b0be !important; /* Softer gray for muted text */
    }
    
    body.theme-dark .progress-bar {
      background-color: #487eb0 !important; /* Consistent muted blue for progress bars */
    }
    
    /* Pastel Theme */
    body.theme-pastel {
      background-color: #f8f9fa; /* Light background */
      color: #5a6268; /* Neutral text color for readability */
    }

    body.theme-pastel .card {
      background-color: #ffffff; /* White card background */
      border-color: #e9ecef; /* Light border for cards */
      color: #4b0082; /* Neutral text color for readability */
    }

    body.theme-pastel .card-header {
      background-color: #e6e6fa; /* Lavender background */
      color: #4b0082; /* Indigo text for readability */
      border-bottom: 1px solid #d8bfd8; /* Thistle border for subtle separation */
    }
    
    
    /* Vivid Theme */
    body.theme-vivid {
      background-color: #ffffff;
      color: #212529;
    }
    
    body.theme-vivid .card {
      background-color: #ffffff; /* White card background */
      border-color: #dee2e6; /* Light border for cards */
      color: #212529; /* Black text for readability */
    }
    
    body.theme-vivid .card-header {
      background-color: #007bff; /* Bright blue header background */
      color: #ffffff; /* White text for contrast */
      border-bottom: 1px solid #0056b3; /* Subtle border for separation */
    }
    
    
    /* Default theme and other themes */
    .card-header {
      color: #212529 !important; /* Black text for all themes */
    }
    

  
    
    /* Transition effects */
    body, .card, .card-header {
      transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    }
    
    /* Keep the custom font loading but we'll use it for our pixel fonts */
    @import url('https://fonts.googleapis.com/css2?family=Jersey+20&family=VT323&family=Silkscreen:wght@400;700&family=Pixelify+Sans&display=swap');
  </style>

  <h1 class="mt-3 mb-4 text-center gradient-text">Tea Collection Analytics</h1>
  
  <div class="analytics-controls mb-4">
    <div class="row justify-content-center">
      <div class="col-md-auto">
        <div class="control-btn-group">
          <button id="toggleCustomizePanel" class="control-btn customize-btn">
            <i class="bi bi-palette"></i>
            <span>Customize</span>
          </button>
          
          <button id="shareDashboardBtn" class="control-btn share-btn">
            <i class="bi bi-share"></i>
            <span>Share</span>
          </button>
          
          <%= link_to root_path, class: "control-btn back-btn" do %>
            <i class="bi bi-house"></i>
            <span>Back to Home</span>
          <% end %>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Customization Panel -->
  <div id="customizePanel" class="card shadow-sm mb-4" style="display: none;">
    <div class="card-header">
      <h5 class="mb-0">Customize Your Analytics Dashboard</h5>
    </div>
    <div class="card-body">
      <div class="row">
        <div class="col-md-4">
          <h6>Dashboard Theme</h6>
          <div class="d-flex flex-wrap gap-2 mb-3">
            <div class="form-check form-check-inline">
              <input class="form-check-input" type="radio" name="dashboardTheme" id="themeDefault" value="default" checked>
              <label class="form-check-label" for="themeDefault">Default</label>
            </div>
            <div class="form-check form-check-inline">
              <input class="form-check-input" type="radio" name="dashboardTheme" id="themeDark" value="dark">
              <label class="form-check-label" for="themeDark">Dark</label>
            </div>
            <div class="form-check form-check-inline">
              <input class="form-check-input" type="radio" name="dashboardTheme" id="themePastel" value="pastel">
              <label class="form-check-label" for="themePastel">Pastel</label>
            </div>
            <div class="form-check form-check-inline">
              <input class="form-check-input" type="radio" name="dashboardTheme" id="themeVivid" value="vivid">
              <label class="form-check-label" for="themeVivid">Vivid</label>
            </div>
          </div>
          
          <div class="mb-3">
            <label for="cardHeadersColor" class="form-label">Card Headers Style</label>
            <select class="form-select" id="cardHeadersStyle">
              <option value="default" selected>Default</option>
              <option value="solid">Solid Colors</option>
              <option value="gradient">Gradient</option>
              <option value="subtle">Subtle</option>
              <option value="monochrome">Monochrome</option>
            </select>
          </div>
        </div>
        
        <div class="col-md-4">
          <h6>Chart Colors</h6>
          <div class="mb-3">
            <label for="categoryChartColors" class="form-label">Category Chart</label>
            <select class="form-select" id="categoryChartColors">
              <option value="default" selected>Default</option>
              <option value="tea">Tea Colors</option>
              <option value="pastels">Pastel Colors</option>
              <option value="monochrome">Monochrome</option>
            </select>
          </div>
          <div class="mb-3">
            <label for="mapLineColor" class="form-label">Map Lines</label>
            <input type="color" class="form-control form-control-color" id="mapLineColor" value="#ff637c" title="Choose map line color">
          </div>
        </div>
        
        <div class="col-md-4">
          <h6>Text & Header Colors</h6>
          <div class="mb-3">
            <label for="chartTextColor" class="form-label">Chart Text Color</label>
            <input type="color" class="form-control form-control-color" id="chartTextColor" value="#333333" title="Choose chart text color">
          </div>
          <div class="mb-3">
            <label for="dashboardTitle" class="form-label">Dashboard Title Color</label>
            <input type="color" class="form-control form-control-color" id="dashboardTitleColor" value="#212529" title="Choose dashboard title color">
          </div>
        </div>
      </div>
      <div class="d-flex justify-content-between mt-2">
        <button id="resetCustomizations" class="btn btn-secondary">Reset to Default</button>
        <button id="saveCustomizations" class="btn btn-success">Save Preferences</button>
      </div>
    </div>
  </div>
  
  <!-- Analytics Overview -->
  <div class="row mb-4">
    <div class="col-md-3">
      <div class="stats-card bg-success">
        <div class="stats-card-inner">
          <h1 class="stats-value"><%= @total_teas %></h1>
          <p class="stats-label">Total Teas</p>
        </div>
      </div>
    </div>
    
    <div class="col-md-3">
      <div class="stats-card bg-primary">
        <div class="stats-card-inner">
          <h1 class="stats-value"><%= @tea_categories.count %></h1>
          <p class="stats-label">Categories</p>
        </div>
      </div>
    </div>
    
    <div class="col-md-3">
      <div class="stats-card bg-warning">
        <div class="stats-card-inner">
          <h1 class="stats-value"><%= @avg_rank ? @avg_rank.round(1) : 'N/A' %></h1>
          <p class="stats-label">Avg. Rank</p>
        </div>
      </div>
    </div>
    
    <div class="col-md-3">
      <div class="stats-card bg-info">
        <div class="stats-card-inner">
          <h1 class="stats-value"><%= number_to_currency(@total_value) %></h1>
          <p class="stats-label">Collection Value</p>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Category Analysis -->
  <div class="row mb-4">
    <div class="col-md-6">
      <div class="card shadow-sm h-100">
        <div class="card-header">
          <div class="d-flex justify-content-between align-items-center">
            <h5 class="mb-0">Category Distribution</h5>
            <button class="btn btn-sm btn-light share-chart-btn" data-chart="categoryChart" data-title="Tea Categories Distribution">
              <i class="bi bi-share"></i> Share
            </button>
          </div>
        </div>
        <div class="card-body">
          <div class="category-chart" style="height: 300px;">
            <canvas id="categoryChart" style="width:100%;height:100%;"></canvas>
          </div>
        </div>
      </div>
    </div>
    
    <div class="col-md-6">
      <div class="card shadow-sm h-100">
        <div class="card-header">
          <div class="d-flex justify-content-between align-items-center">
            <h5 class="mb-0">Average Rank by Category</h5>
            <button class="btn btn-sm btn-light share-chart-btn" data-chart="rankByCategory" data-title="Average Rank by Tea Category">
              <i class="bi bi-share"></i> Share
            </button>
          </div>
        </div>
        <div class="card-body">
          <% @category_avg_ranks.each do |category, avg_rank| %>
            <div class="d-flex align-items-center mb-3">
              <div class="me-3 text-end" style="width: 100px;">
                <strong><%= category %></strong>
              </div>
              <div class="progress flex-grow-1" style="height: 25px;">
                <div class="progress-bar bg-success" role="progressbar" 
                     style="width: <%= (avg_rank.to_f / @total_teas) * 100 %>%;" 
                     aria-valuenow="<%= avg_rank %>" aria-valuemin="0" aria-valuemax="100">
                  <%= avg_rank.round(1) %>
                </div>
              </div>
            </div>
          <% end %>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Origin Analysis -->
  <div class="row mb-4">
    <div class="col-md-12">
      <div class="card shadow-sm">
        <div class="card-header d-flex justify-content-between align-items-center">
          <h5 class="mb-0">Tea Origins Map</h5>
          <div>
            <button class="btn btn-sm btn-light share-chart-btn me-2" data-chart="worldMap" data-title="Tea Origins Map">
              <i class="bi bi-share"></i> Share
            </button>
            <button id="toggleMapDetails" class="btn btn-sm btn-light">Show Details</button>
          </div>
        </div>
        <div class="card-body">
          <div class="origins-map" style="height: 400px; position: relative;">
            <div id="worldMap" style="width:100%;height:100%;"></div>
            <div id="mapDetails" class="bg-white shadow-sm border rounded p-2" style="position: absolute; bottom: 10px; right: 10px; max-width: 300px; max-height: 200px; overflow-y: auto; display: none; z-index: 1000; font-size: 12px;">
              <h6 class="mb-2">Tea Origins</h6>
              <div id="originsList"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Price Analysis -->
  <div class="row mb-4">
    <div class="col-md-6">
      <div class="retro-card">
        <div class="card-header">
          <div class="d-flex justify-content-between align-items-center">
            <h5 class="mb-0">Price vs. Rank Analysis</h5>
            <button class="retro-share-btn" data-chart="priceRankChart" data-title="Price vs. Rank Analysis">
              <i class="bi bi-share"></i> <span>Share</span>
            </button>
          </div>
        </div>
        <div class="card-body">
          <div class="price-rank-chart" style="height: 300px;">
            <canvas id="priceRankChart" style="width:100%;height:100%;"></canvas>
          </div>
        </div>
      </div>
    </div>
    
    <div class="col-md-6">
      <div class="retro-card">
        <div class="card-header">
          <div class="d-flex justify-content-between align-items-center">
            <h5 class="mb-0">Price Distribution by Vendor</h5>
            <button class="retro-share-btn" data-chart="vendorPriceChart" data-title="Price Distribution by Vendor">
              <i class="bi bi-share"></i> <span>Share</span>
            </button>
          </div>
        </div>
        <div class="card-body">
          <div class="vendor-price-chart" style="height: 300px;">
            <canvas id="vendorPriceChart" style="width:100%;height:100%;"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // Get the data from controller
  const categoryData = <%= raw @tea_type_counts.to_json %>;
  const originData = <%= raw @popular_ship_from.to_json %>;
  const teasData = <%= raw @teas.to_json(only: [:id, :name, :price, :grams, :vendor, :category, :ship_from]) %>;
  
  // Create a mapping of tea ranks directly from entries
  const rankData = {};
  <% current_user.entries.each do |entry| %>
    rankData[<%= entry.tea_id %>] = <%= entry.rank %>;
  <% end %>
  
  console.log("Tea rank mapping:", rankData);
  
  // Set up global chart defaults for consistent text colors and fonts
  Chart.defaults.color = '#333333';
  Chart.defaults.font.family = getComputedStyle(document.body).getPropertyValue('--font-pixel') || "'Jersey 20', 'VT323', 'Silkscreen', 'Pixelify Sans', 'DotGothic16', 'Press Start 2P', monospace";
  Chart.defaults.plugins.legend.labels.color = '#333333';
  Chart.defaults.plugins.title.color = '#333333';
  
  // Category Distribution Chart
  function renderCategoryChart() {
    const ctx = document.getElementById('categoryChart').getContext('2d');
    if (!ctx) return;
    
    const categories = Object.keys(categoryData);
    const counts = Object.values(categoryData);
    
    const backgroundColor = [
      'rgba(54, 162, 235, 0.6)', // blue
      'rgba(255, 99, 132, 0.6)', // pink
      'rgba(75, 192, 192, 0.6)', // green
      'rgba(255, 206, 86, 0.6)', // yellow
      'rgba(153, 102, 255, 0.6)', // purple
      'rgba(255, 159, 64, 0.6)', // orange
      'rgba(199, 199, 199, 0.6)' // gray
    ];
    
    window.categoryChart = new Chart(ctx, {
      type: 'pie',
      data: {
        labels: categories,
        datasets: [{
          data: counts,
          backgroundColor: backgroundColor.slice(0, categories.length),
          borderColor: backgroundColor.map(color => color.replace('0.6', '1')),
          borderWidth: 1
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'right',
            labels: {
              font: {
                family: getComputedStyle(document.body).getPropertyValue('--font-pixel') || "'Jersey 20', 'VT323', 'Silkscreen', 'Pixelify Sans', 'DotGothic16', 'Press Start 2P', monospace",
                size: 12
              }
            }
          },
          tooltip: {
            callbacks: {
              label: function(context) {
                const label = context.label || '';
                const value = context.raw || 0;
                const total = counts.reduce((a, b) => a + b, 0);
                const percentage = Math.round((value / total) * 100);
                return `${label}: ${value} (${percentage}%)`;
              }
            }
          }
        }
      }
    });
    
    return window.categoryChart;
  }
  
  // New Simplified World Map Implementation
  function renderWorldMap() {
    const mapElement = document.getElementById('worldMap');
    if (!mapElement) return;
    
    // More comprehensive mapping with cities/regions included
    const locationCoordinates = {
      // Countries
      'China': [35.8617, 104.1954],
      'Taiwan': [23.6978, 120.9605],
      'Japan': [36.2048, 138.2529],
      'India': [20.5937, 78.9629],
      'Vietnam': [14.0583, 108.2772],
      'Korea': [35.9078, 127.7669],
      'South Korea': [35.9078, 127.7669],
      'Thailand': [15.8700, 100.9925],
      'Malaysia': [4.2105, 101.9758],
      'Sri Lanka': [7.8731, 80.7718],
      'Nepal': [28.3949, 84.1240],
      'Kenya': [-1.2921, 36.8219],
      'United Kingdom': [55.3781, -3.4360],
      'United States': [37.0902, -95.7129],
      'Indonesia': [-0.7893, 113.9213],
      'Myanmar': [21.9162, 95.9560],
      'Laos': [19.8563, 102.4955],
      
      // Chinese regions/cities
      'Yunnan': [25.0453, 102.7097],
      'Fujian': [26.0789, 117.9874],
      'Guangdong': [23.3790, 113.7633],
      'Hangzhou': [30.2741, 120.1551],
      'Fuding': [27.3260, 120.2000],
      'Anxi': [25.0563, 118.1868],
      'Wuyi': [27.7617, 117.8413],
      'Guangxi': [23.7248, 108.8076],
      'Sichuan': [30.6570, 104.0650],
      'Beijing': [39.9042, 116.4074],
      'Shanghai': [31.2304, 121.4737],
      'Zhejiang': [29.1416, 119.7889],
      'Hubei': [30.7378, 112.2384],
      'Hunan': [27.6253, 111.8569],
      'Shaanxi': [35.3911, 109.1882],
      
      // Taiwan regions
      'Taipei': [25.0330, 121.5654],
      'Nantou': [23.9609, 120.9718],
      'Hualien': [23.9749, 121.6059],
      
      // Japan regions
      'Shizuoka': [34.9756, 138.3827],
      'Kyoto': [35.0116, 135.7681],
      'Uji': [34.8811, 135.8009],
      'Kagoshima': [31.5969, 130.5571],
      
      // India regions
      'Darjeeling': [27.0360, 88.2627],
      'Assam': [26.2006, 92.9376],
      'Nilgiri': [11.4916, 76.7399],
      'Sikkim': [27.5330, 88.5122],
    };
    
    // Initialize the map
    const map = L.map('worldMap').setView([30, 100], 2);
    
    // Add the base map layer
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
  attribution: '&copy; <a href="https://carto.com/">CARTO</a>',
  subdomains: 'abcd',
  maxZoom: 19
}).addTo(map);

    
    // Home location
    const homeLocation = [40, -95]; // US center
    
    // Add home marker
    const homeMarker = L.marker(homeLocation, {
      icon: L.divIcon({
        className: 'home-icon',
        html: '<i class="bi bi-house-fill" style="color: blue; font-size: 24px;"></i>',
        iconSize: [24, 24],
        iconAnchor: [12, 12]
      })
    }).addTo(map).bindPopup('Your Location');
    
    // Process and display origins
    const origins = Object.keys(originData);
    
    // Populate the details panel
    const originsList = document.getElementById('originsList');
    if (originsList) {
      originsList.innerHTML = origins.map(origin => 
        `<div class="mb-1">
           <strong>${origin}</strong>: ${originData[origin]} teas
         </div>`
      ).join('');
    }
    
    // Tea icon style
    const teaIcon = L.divIcon({
      className: 'tea-icon',
      html: '<i class="bi bi-cup-hot-fill" style="color: green; font-size: 20px;"></i>',
      iconSize: [20, 20],
      iconAnchor: [10, 10]
    });
    
    // Create a layer group for all tea markers and lines
    const teaGroup = L.layerGroup().addTo(map);
    
    // Track unmapped origins
    const unmappedOrigins = [];
    
    // Add markers and lines for each origin
    origins.forEach(origin => {
      // Skip if origin is empty
      if (!origin || origin.trim() === '') return;
      
      // Get count of teas from this origin
      const count = originData[origin];
      
      // Try to find coordinates (case-insensitive)
      let coords;
      const originLower = origin.toLowerCase();
      
      for (const [key, value] of Object.entries(locationCoordinates)) {
        if (key.toLowerCase() === originLower) {
          coords = value;
          break;
        }
      }
      
      // If origin not found, use approximate coordinates by geocoding
      if (!coords) {
        console.warn(`No predefined coordinates for: ${origin}, assigning to China as fallback`);
        unmappedOrigins.push(origin);
        // Fallback to China coordinates
        coords = [35.8617, 104.1954]; 
      }
      
      // Add marker for this origin
      const marker = L.marker(coords, { icon: teaIcon })
        .bindPopup(`<strong>${origin}</strong><br>${count} teas`)
        .addTo(teaGroup);
      
      // Add a straight line connecting to home
      const line = L.polyline([coords, homeLocation], {
        color: 'rgba(255, 99, 132, 0.6)',
        weight: Math.max(1, Math.min(Math.floor(count / 10) + 1, 5)),
        dashArray: '5, 5'
      }).addTo(teaGroup);
      
      // Add arrow to the line
      const arrowHead = L.polylineDecorator(line, {
        patterns: [
          {
            offset: '60%',
            repeat: 0,
            symbol: L.Symbol.arrowHead({
              pixelSize: 10,
              headAngle: 30,
              polygon: true,
              pathOptions: { color: 'rgba(255, 99, 132, 0.8)', fillOpacity: 0.8 }
            })
          }
        ]
      }).addTo(teaGroup);
    });
    
    // Show unmapped origins warning if any
    if (unmappedOrigins.length > 0) {
      const warningDiv = document.createElement('div');
      warningDiv.className = 'bg-warning text-dark p-2 rounded';
      warningDiv.style.position = 'absolute';
      warningDiv.style.bottom = '10px';
      warningDiv.style.left = '10px';
      warningDiv.style.zIndex = '1000';
      warningDiv.style.maxWidth = '250px';
      warningDiv.style.fontSize = '12px';
      
      warningDiv.innerHTML = `
        <p class="mb-1"><strong>Some origins mapped to China:</strong></p>
        <p class="mb-0">${unmappedOrigins.join(', ')}</p>
      `;
      
      document.querySelector('.origins-map').appendChild(warningDiv);
    }
    
    // Add event listener for the toggle button
    document.getElementById('toggleMapDetails').addEventListener('click', function() {
      const detailsPanel = document.getElementById('mapDetails');
      if (detailsPanel.style.display === 'none') {
        detailsPanel.style.display = 'block';
        this.textContent = 'Hide Details';
      } else {
        detailsPanel.style.display = 'none';
        this.textContent = 'Show Details';
      }
    });
    
    // Force a map resize to ensure all is displaying properly
    setTimeout(() => map.invalidateSize(), 100);
  }
  
  // Price vs Rank Correlation Chart (Scatter Plot)
  function renderPriceRankChart() {
    const ctx = document.getElementById('priceRankChart').getContext('2d');
    if (!ctx) return;
    
    // Debug the teas data
    console.log('Tea data received:', teasData);
    console.log('Rank data mapping:', rankData);
    
    // Try to identify fields - different models might name them differently
    const sampleTea = teasData.length > 0 ? teasData[0] : null;
    if (sampleTea) {
      console.log('Sample tea structure:', Object.keys(sampleTea));
      console.log('Sample tea data:', sampleTea);
    }
    
    // CRITICAL FIX: Use the rankData mapping to get ranks for each tea
    const validTeas = teasData.filter(tea => {
      // Get price, which we know exists on the tea directly
      let price = 0, grams = 0;
      
      try {
        price = typeof tea.price === 'number' ? tea.price : parseFloat(tea.price || 0);
      } catch (e) {
        price = 0;
      }

      // Try to get grams
      try {
        grams = typeof tea.grams === 'number' ? tea.grams : parseFloat(tea.grams || 1);
      } catch (e) {
        grams = 1;
      }
      
      // Get rank from our rankData mapping
      const rank = rankData[tea.id] || 0;
      
      console.log(`Tea: ${tea.name || 'unknown'}, ID: ${tea.id}, Price: ${price}, Grams: ${grams}, Rank: ${rank}`);
      
      // Include tea in chart if we can calculate price per gram and have some rank info
      return price > 0 && rank > 0;
    });
    
    console.log(`Found ${validTeas.length} valid teas for price-rank chart`);
    
    if (validTeas.length === 0) {
      console.warn('No valid teas with price and rank data for the scatter plot');
      // Display a more informative message
      const chartContainer = document.querySelector('.price-rank-chart');
      if (chartContainer) {
        chartContainer.innerHTML = `
          <div class="alert alert-warning text-center my-5">
            <p>No teas with complete price and rank data could be processed.</p>
            <p>Rank data likely exists in the entries relation, not on tea objects directly.</p>
            <p class="small text-muted">Received ${teasData.length} teas, but couldn't extract rank information.</p>
            <button id="debugDataBtn" class="btn btn-sm btn-outline-primary mt-2">Show Sample Data</button>
          </div>
        `;
        
        // Add event listener for the debug button
        setTimeout(() => {
          const debugBtn = document.getElementById('debugDataBtn');
          if (debugBtn) {
            debugBtn.addEventListener('click', () => {
              if (sampleTea) {
                alert(JSON.stringify(sampleTea, null, 2));
              } else {
                alert('No sample tea data available');
              }
            });
          }
        }, 100);
      }
      return;
    }
    
    // Prepare data for scatter plot
    const scatterData = validTeas.map(tea => {
      let price, grams;
      
      // Get price
      try {
        price = typeof tea.price === 'number' ? tea.price : parseFloat(tea.price || 0);
      } catch (e) {
        price = 0;
      }
      
      // Get grams
      try {
        grams = typeof tea.grams === 'number' ? tea.grams : parseFloat(tea.grams || 1);
        if (grams <= 0) grams = 1; // Avoid division by zero
      } catch (e) {
        grams = 1;
      }
      
      // Get rank from rankData mapping
      const rank = rankData[tea.id] || 0;
      
      // Calculate price per gram
      const pricePerGram = grams > 0 ? price / grams : price;
      
      return {
        x: pricePerGram, // Price per gram
        y: rank,
        label: tea.name || 'Unnamed Tea',
        category: tea.category || 'Unknown',
        price: price,
        grams: grams
      };
    });
    
    // Get unique categories for color coding
    const uniqueCategories = [...new Set(validTeas.map(tea => tea.category || 'Unknown'))];
    const colorPalette = [
      'rgba(255, 99, 132, 0.6)',  // pink
      'rgba(54, 162, 235, 0.6)',  // blue
      'rgba(255, 206, 86, 0.6)',  // yellow
      'rgba(75, 192, 192, 0.6)',  // green
      'rgba(153, 102, 255, 0.6)', // purple
      'rgba(255, 159, 64, 0.6)'   // orange
    ];
    
    // Create datasets, one for each category
    const datasets = uniqueCategories.map((category, index) => {
      const color = colorPalette[index % colorPalette.length];
      return {
        label: category,
        data: scatterData.filter(point => point.category === category),
        backgroundColor: color,
        borderColor: color.replace('0.6', '1'),
        pointRadius: 6,
        pointHoverRadius: 8
      };
    });
    
    window.priceRankChart = new Chart(ctx, {
      type: 'scatter',
      data: {
        datasets: datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          tooltip: {
            callbacks: {
              label: function(context) {
                const point = context.raw;
                const labels = [
                  `Name: ${point.label}`,
                  `Price/Gram: $${point.x.toFixed(3)}/g`,
                  `Price: $${point.price.toFixed(2)}`,
                  `Rank: ${point.y}`,
                ];
                
                if (point.grams > 0) {
                  labels.splice(3, 0, `Grams: ${point.grams}g`);
                }
                
                if (point.category && point.category !== 'Unknown') {
                  labels.push(`Category: ${point.category}`);
                }
                
                return labels;
              }
            }
          },
          legend: {
            position: 'top',
          }
        },
        scales: {
          x: {
            type: 'linear',
            position: 'bottom',
            title: {
              display: true,
              text: 'Price per Gram ($/g)',
              font: {
                family: getComputedStyle(document.body).getPropertyValue('--font-pixel') || "'Jersey 20', 'VT323', 'Silkscreen', 'Pixelify Sans', 'DotGothic16', 'Press Start 2P', monospace",
                weight: 'bold'
              }
            },
            ticks: {
              callback: value => `$${value.toFixed(2)}`,
              font: {
                family: getComputedStyle(document.body).getPropertyValue('--font-pixel') || "'Jersey 20', 'VT323', 'Silkscreen', 'Pixelify Sans', 'DotGothic16', 'Press Start 2P', monospace"
              }
            }
          },
          y: {
            title: {
              display: true,
              text: 'Rank',
              font: {
                family: getComputedStyle(document.body).getPropertyValue('--font-pixel') || "'Jersey 20', 'VT323', 'Silkscreen', 'Pixelify Sans', 'DotGothic16', 'Press Start 2P', monospace",
                weight: 'bold'
              }
            },
            ticks: {
              font: {
                family: getComputedStyle(document.body).getPropertyValue('--font-pixel') || "'Jersey 20', 'VT323', 'Silkscreen', 'Pixelify Sans', 'DotGothic16', 'Press Start 2P', monospace"
              }
            }
          }
        }
      }
    });
    
    return window.priceRankChart;
  }
  
  // Vendor Price Distribution Chart (Box Plot-like using bar chart)
  function renderVendorPriceChart() {
    const ctx = document.getElementById('vendorPriceChart').getContext('2d');
    if (!ctx) return;
    
    console.log('Rendering vendor price chart...');
    
    // Create a more flexible grouping function to handle different data structures
    const vendorGroups = {};
    teasData.forEach(tea => {
      // Convert potential string values to numbers
      let price = 0, grams = 0;
      const vendor = tea.vendor || tea.company || '';
      
      try {
        price = typeof tea.price === 'number' ? tea.price : parseFloat(tea.price || 0);
      } catch (e) {
        price = 0;
      }
      
      try {
        grams = typeof tea.grams === 'number' ? tea.grams : parseFloat(tea.grams || 1);
        if (grams <= 0) grams = 1; // Avoid division by zero
      } catch (e) {
        grams = 1;
      }
      
      if (price > 0 && vendor) {
        if (!vendorGroups[vendor]) {
          vendorGroups[vendor] = [];
        }
        
        // Always store price per gram
        const pricePerGram = price / grams;
        vendorGroups[vendor].push({
          price: price,
          pricePerGram: pricePerGram,
          grams: grams,
          value: pricePerGram
        });
      }
    });
    
    // Check if we have vendor data
    const vendorCount = Object.keys(vendorGroups).length;
    console.log(`Found ${vendorCount} vendors with price data`);
    
    if (vendorCount === 0) {
      console.warn('No vendor price data available');
      // Display a message in the chart area
      const chartContainer = document.querySelector('.vendor-price-chart');
      if (chartContainer) {
        chartContainer.innerHTML = `
          <div class="alert alert-warning text-center my-5">
            <p>No teas with vendor and price data available.</p>
            <p>Please add vendor and price information to your teas.</p>
            <p class="small text-muted">Received ${teasData.length} teas, but none had valid vendor and price.</p>
          </div>
        `;
      }
      return;
    }
    
    // Calculate average price per vendor
    const vendorAvgPrices = {};
    Object.keys(vendorGroups).forEach(vendor => {
      const prices = vendorGroups[vendor].map(item => item.value);
      vendorAvgPrices[vendor] = prices.reduce((sum, price) => sum + price, 0) / prices.length;
    });
    
    // Sort vendors by average price
    const sortedVendors = Object.keys(vendorAvgPrices).sort((a, b) => 
      vendorAvgPrices[b] - vendorAvgPrices[a]
    );
    
    // Show ALL vendors - no cap
    const displayVendors = sortedVendors;
    const displayAvgPrices = displayVendors.map(vendor => vendorAvgPrices[vendor]);
    const teaCounts = displayVendors.map(vendor => vendorGroups[vendor].length);
    
    // Always use price per gram for consistency
    const priceLabel = 'Average Price per Gram';
    const yAxisTitle = 'Price per Gram ($/g)';
    
    window.vendorPriceChart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: displayVendors,
        datasets: [{
          label: priceLabel,
          data: displayAvgPrices,
          backgroundColor: 'rgba(255, 99, 132, 0.6)',
          borderColor: 'rgba(255, 99, 132, 1)',
          borderWidth: 1
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          tooltip: {
            callbacks: {
              label: function(context) {
                const vendor = context.label;
                const avgPrice = context.raw.toFixed(2); // Fixed to 2 decimal places for price formatting
                const count = teaCounts[context.dataIndex];
                return [
                  `Price/Gram: $${avgPrice}/g`,
                  `Tea Count: ${count}`
                ];
              }
            }
          }
        },
        scales: {
          x: {
            title: {
              display: true,
              text: 'Vendor',
              font: {
                family: getComputedStyle(document.body).getPropertyValue('--font-pixel') || "'Jersey 20', 'VT323', 'Silkscreen', 'Pixelify Sans', 'DotGothic16', 'Press Start 2P', monospace",
                weight: 'bold'
              }
            },
            ticks: {
              maxRotation: 45,
              minRotation: 45,
              autoSkip: false, // Ensure all vendors are shown
              font: {
                family: getComputedStyle(document.body).getPropertyValue('--font-pixel') || "'Jersey 20', 'VT323', 'Silkscreen', 'Pixelify Sans', 'DotGothic16', 'Press Start 2P', monospace"
              }
            }
          },
          y: {
            beginAtZero: true,
            title: {
              display: true,
              text: yAxisTitle,
              font: {
                family: getComputedStyle(document.body).getPropertyValue('--font-pixel') || "'Jersey 20', 'VT323', 'Silkscreen', 'Pixelify Sans', 'DotGothic16', 'Press Start 2P', monospace",
                weight: 'bold'
              }
            },
            ticks: {
              // Fixed to 2 decimal places for price formatting
              callback: value => `$${value.toFixed(2)}`,
              font: {
                family: getComputedStyle(document.body).getPropertyValue('--font-pixel') || "'Jersey 20', 'VT323', 'Silkscreen', 'Pixelify Sans', 'DotGothic16', 'Press Start 2P', monospace"
              }
            }
          }
        }
      }
    });
    
    return window.vendorPriceChart;
  }
  
  // Call all chart rendering functions
  if (document.getElementById('categoryChart')) renderCategoryChart();
  if (document.getElementById('priceRankChart')) renderPriceRankChart();
  if (document.getElementById('vendorPriceChart')) renderVendorPriceChart();
  renderWorldMap();
  
  // Dashboard Customization Feature
  const customizePanel = document.getElementById('customizePanel');
  const toggleCustomizePanel = document.getElementById('toggleCustomizePanel');
  let charts = {}; // Store chart instances for re-rendering
  
  // Color theme palettes
  const colorThemes = {
    default: [
      'rgba(54, 162, 235, 0.6)', // blue
      'rgba(255, 99, 132, 0.6)', // pink
      'rgba(75, 192, 192, 0.6)', // green
      'rgba(255, 206, 86, 0.6)', // yellow
      'rgba(153, 102, 255, 0.6)', // purple
      'rgba(255, 159, 64, 0.6)'  // orange
    ],
    tea: [
      'rgba(183, 110, 39, 0.6)',  // brown
      'rgba(104, 160, 99, 0.6)',  // green
      'rgba(196, 145, 2, 0.6)',   // yellow
      'rgba(181, 71, 82, 0.6)',   // red
      'rgba(76, 40, 30, 0.6)',    // dark brown
      'rgba(192, 171, 142, 0.6)'  // beige
    ],
    pastels: [
      'rgba(255, 179, 198, 0.6)', // pink
      'rgba(181, 234, 215, 0.6)', // mint
      'rgba(255, 241, 179, 0.6)', // light yellow
      'rgba(199, 206, 234, 0.6)', // lavender
      'rgba(235, 179, 255, 0.6)', // light purple
      'rgba(181, 228, 255, 0.6)'  // sky blue
    ],
    monochrome: [
      'rgba(44, 62, 80, 0.8)',
      'rgba(44, 62, 80, 0.7)',
      'rgba(44, 62, 80, 0.6)', 
      'rgba(44, 62, 80, 0.5)',
      'rgba(44, 62, 80, 0.4)',
      'rgba(44, 62, 80, 0.3)'
    ]
  };
  
  // Save preferences to localStorage
  function savePreferences() {
    try {
      const prefs = {
        dashboardTheme: document.querySelector('input[name="dashboardTheme"]:checked').value,
        categoryChartColors: document.getElementById('categoryChartColors').value,
        mapLineColor: document.getElementById('mapLineColor').value,
        chartTextColor: document.getElementById('chartTextColor').value,
        cardHeadersStyle: document.getElementById('cardHeadersStyle').value,
        dashboardTitleColor: document.getElementById('dashboardTitleColor')?.value || '#212529'
      };
      
      localStorage.setItem('teaTrackerDashboardPrefs', JSON.stringify(prefs));
      
      // Show save confirmation
      const saveBtn = document.getElementById('saveCustomizations');
      const originalText = saveBtn.textContent;
      saveBtn.textContent = 'Saved!';
      saveBtn.classList.remove('btn-success');
      saveBtn.classList.add('btn-info');
      
      setTimeout(() => {
        saveBtn.textContent = originalText;
        saveBtn.classList.remove('btn-info');
        saveBtn.classList.add('btn-success');
      }, 2000);
      
    } catch (e) {
      console.error('Error saving preferences:', e);
    }
  }
  
  // Load saved preferences from localStorage
  function loadPreferences() {
    try {
      const savedPrefs = localStorage.getItem('teaTrackerDashboardPrefs');
      if (savedPrefs) {
        const prefs = JSON.parse(savedPrefs);
        
        // Apply theme
        document.querySelector(`input[name="dashboardTheme"][value="${prefs.dashboardTheme || 'default'}"]`).checked = true;
        
        // Apply chart colors
        if (prefs.categoryChartColors) {
          document.getElementById('categoryChartColors').value = prefs.categoryChartColors;
        }
        
        // Apply map color
        if (prefs.mapLineColor) {
          document.getElementById('mapLineColor').value = prefs.mapLineColor;
        }
        
        // Apply text color
        if (prefs.chartTextColor) {
          document.getElementById('chartTextColor').value = prefs.chartTextColor;
        }
        
        // Apply card header style
        if (prefs.cardHeadersStyle) {
          document.getElementById('cardHeadersStyle').value = prefs.cardHeadersStyle;
        }
        
        // Apply dashboard title color
        if (prefs.dashboardTitleColor && document.getElementById('dashboardTitleColor')) {
          document.getElementById('dashboardTitleColor').value = prefs.dashboardTitleColor;
        }
        
        // Apply all preferences
        applyPreferences();
      }
    } catch (e) {
      console.error('Error loading preferences:', e);
    }
  }
  
  // Apply preferences to dashboard
  function applyPreferences() {
    // Get current preferences
    const theme = document.querySelector('input[name="dashboardTheme"]:checked').value;
    const categoryColors = document.getElementById('categoryChartColors').value;
    const mapColor = document.getElementById('mapLineColor').value;
    const textColor = document.getElementById('chartTextColor').value;
    const headerStyle = document.getElementById('cardHeadersStyle').value;
    const titleColor = document.getElementById('dashboardTitleColor')?.value || '#212529';
    
    // Apply theme
    applyTheme(theme);
    
    // Apply card header styles
    updateCardHeadersAndStats(headerStyle);
    
    // Update dashboard title color
    const dashboardTitle = document.querySelector('.container-fluid > .d-flex > h1');
    if (dashboardTitle) {
      dashboardTitle.style.color = titleColor;
    }
    
    // Re-render charts with new colors
    updateChartColors(categoryColors, textColor);
    
    // Update map colors
    updateMapColors(mapColor);
  }
  
  // Update card headers and statistic cards
  function updateCardHeadersAndStats(style) {
    const headers = document.querySelectorAll('.card-header');
    const statCards = document.querySelectorAll('.row:first-of-type .card');
    const progressBars = document.querySelectorAll('.progress-bar');
    const selectedColors = colorThemes[document.getElementById('categoryChartColors').value] || colorThemes.default;
    
    // Reset headers to default first
    headers.forEach(header => {
      header.style.background = '';
      header.style.borderBottom = '';
      header.style.color = '';
    });
    
    // Reset stat cards first
    statCards.forEach(card => {
      if (!card.classList.contains('bg-success') && 
          !card.classList.contains('bg-primary') && 
          !card.classList.contains('bg-warning') && 
          !card.classList.contains('bg-info')) return;
          
      card.style.background = '';
      card.style.backgroundColor = '';
      card.style.color = '';
    });
    
    // Apply header styles
    if (style === 'solid') {
      // Solid vibrant colors
      headers.forEach((header, i) => {
        const colorIdx = i % selectedColors.length;
        const color = selectedColors[colorIdx].replace('0.6', '1');
        header.style.backgroundColor = color;
        header.style.color = '#ffffff';
        header.style.borderBottom = 'none';
      });
      
      // Apply to stat cards
      statCards.forEach((card, i) => {
        if (!card.classList.contains('bg-success') && 
            !card.classList.contains('bg-primary') && 
            !card.classList.contains('bg-warning') && 
            !card.classList.contains('bg-info')) return;
            
        const colorIdx = i % selectedColors.length;
        card.style.backgroundColor = selectedColors[colorIdx].replace('0.6', '0.9');
        card.style.color = '#ffffff';
      });
      
      // Apply to progress bars
      progressBars.forEach((bar, i) => {
        const colorIdx = i % selectedColors.length;
        bar.style.backgroundColor = selectedColors[colorIdx].replace('0.6', '0.8');
      });
    } 
    else if (style === 'gradient') {
      // Gradient backgrounds
      headers.forEach((header, i) => {
        const colorIdx = i % selectedColors.length;
        const startColor = selectedColors[colorIdx].replace('0.6', '0.9');
        const endColor = selectedColors[(i+1) % selectedColors.length].replace('0.6', '0.7');
        header.style.background = `linear-gradient(135deg, ${startColor}, ${endColor})`;
        header.style.color = '#ffffff';
        header.style.borderBottom = 'none';
      });
      
      // Apply to stat cards
      statCards.forEach((card, i) => {
        if (!card.classList.contains('bg-success') && 
            !card.classList.contains('bg-primary') && 
            !card.classList.contains('bg-warning') && 
            !card.classList.contains('bg-info')) return;
            
        const colorIdx = i % selectedColors.length;
        const startColor = selectedColors[colorIdx].replace('0.6', '0.9');
        const endColor = selectedColors[(i+1) % selectedColors.length].replace('0.6', '0.7');
        card.style.background = `linear-gradient(135deg, ${startColor}, ${endColor})`;
        card.style.color = '#ffffff';
      });
      
      // Apply to progress bars
      progressBars.forEach((bar, i) => {
        const colorIdx = i % selectedColors.length;
        const startColor = selectedColors[colorIdx].replace('0.6', '0.8');
        const endColor = selectedColors[(i+1) % selectedColors.length].replace('0.6', '0.6');
        bar.style.background = `linear-gradient(90deg, ${startColor}, ${endColor})`;
      });
    }
    else if (style === 'subtle') {
      // Subtle backgrounds with border
      headers.forEach((header, i) => {
        const colorIdx = i % selectedColors.length;
        const color = selectedColors[colorIdx].replace('0.6', '0.3');
        const borderColor = selectedColors[colorIdx].replace('0.6', '0.8');
        header.style.backgroundColor = color;
        header.style.borderBottom = `2px solid ${borderColor}`;
        header.style.color = '#333333';
      });
      
      // Apply to stat cards
      statCards.forEach((card, i) => {
        if (!card.classList.contains('bg-success') && 
            !card.classList.contains('bg-primary') && 
            !card.classList.contains('bg-warning') && 
            !card.classList.contains('bg-info')) return;
            
        const colorIdx = i % selectedColors.length;
        const color = selectedColors[colorIdx].replace('0.6', '0.7');
        card.style.backgroundColor = color;
        card.style.color = '#ffffff';
      });
      
      // Apply to progress bars
      progressBars.forEach((bar, i) => {
        const colorIdx = i % selectedColors.length;
        bar.style.backgroundColor = selectedColors[colorIdx].replace('0.6', '0.8');
      });
    }
    else if (style === 'monochrome') {
      // Monochrome with different shade levels
      headers.forEach((header, i) => {
        const shade = 0.2 + (i % 5) * 0.1; // 0.2, 0.3, 0.4, 0.5, 0.6
        header.style.backgroundColor = `rgba(33, 37, 41, ${shade})`;
        header.style.color = '#ffffff';
        header.style.borderBottom = 'none';
      });
      
      // Apply to stat cards
      statCards.forEach((card, i) => {
        if (!card.classList.contains('bg-success') && 
            !card.classList.contains('bg-primary') && 
            !card.classList.contains('bg-warning') && 
            !card.classList.contains('bg-info')) return;
            
        const shade = 0.5 + (i % 4) * 0.1; // 0.5, 0.6, 0.7, 0.8
        card.style.backgroundColor = `rgba(33, 37, 41, ${shade})`;
        card.style.color = '#ffffff';
      });
      
      // Apply to progress bars
      progressBars.forEach((bar, i) => {
        const shade = 0.5 + (i % 5) * 0.1; // 0.5, 0.6, 0.7, 0.8, 0.9
        bar.style.backgroundColor = `rgba(33, 37, 41, ${shade})`;
      });
    }
  }
  
  // Apply overall theme
  function applyTheme(theme) {
    const root = document.documentElement;
    const cardHeaders = document.querySelectorAll('.card-header');
    const cards = document.querySelectorAll('.card');
    const textColor = document.getElementById('chartTextColor').value;
    
    // Reset previous theme classes
    document.body.classList.remove('theme-dark', 'theme-pastel', 'theme-vivid');
    
    if (theme === 'dark') {
      document.body.classList.add('theme-dark');
      root.style.setProperty('--chart-text-color', '#e0e0e0');
      document.body.style.backgroundColor = '#2c3e50';
      document.body.style.color = '#e0e0e0';
      
      cards.forEach(card => {
        card.style.backgroundColor = '#34495e';
        card.style.borderColor = '#2c3e50';
      });
      
    } else if (theme === 'pastel') {
      document.body.classList.add('theme-pastel');
      root.style.setProperty('--chart-text-color', '#5a6268');
      document.body.style.backgroundColor = '#f8f9fa';
      
      cards.forEach(card => {
        card.style.backgroundColor = '#ffffff';
        card.style.borderColor = '#e9ecef';
      });
      
    } else if (theme === 'vivid') {
      document.body.classList.add('theme-vivid');
      root.style.setProperty('--chart-text-color', '#212529');
      document.body.style.backgroundColor = '#ffffff';
      
      cardHeaders.forEach(header => {
        // Make card headers more vibrant
        if (header.classList.contains('bg-primary')) header.style.backgroundColor = '#007bff';
        if (header.classList.contains('bg-success')) header.style.backgroundColor = '#28a745'; 
        if (header.classList.contains('bg-info')) header.style.backgroundColor = '#17a2b8';
        if (header.classList.contains('bg-warning')) header.style.backgroundColor = '#ffc107';
        if (header.classList.contains('bg-danger')) header.style.backgroundColor = '#dc3545';
      });
      
    } else {
      // Default theme
      root.style.setProperty('--chart-text-color', '#333333');
      document.body.style.backgroundColor = '';
      document.body.style.color = '';
      
      cards.forEach(card => {
        card.style.backgroundColor = '';
        card.style.borderColor = '';
      });
      
      cardHeaders.forEach(header => {
        header.style.backgroundColor = '';
      });
    }
    
    // Apply text color consistently to chart options
    Chart.defaults.color = textColor;
    Chart.defaults.plugins.legend.labels.color = textColor;
    Chart.defaults.plugins.title.color = textColor;
  }
  
  // Update chart colors based on selection
  function updateChartColors(colorScheme, textColor = '#333333') {
    const selectedColors = colorThemes[colorScheme] || colorThemes.default;
    
    // Get the pixel font
    const pixelFont = getComputedStyle(document.body).getPropertyValue('--font-pixel') || "'Jersey 20', 'VT323', 'Silkscreen', 'Pixelify Sans', 'DotGothic16', 'Press Start 2P', monospace";
    
    // Set global chart text color and font
    Chart.defaults.color = textColor;
    Chart.defaults.font.family = pixelFont;
    Chart.defaults.plugins.legend.labels.color = textColor;
    Chart.defaults.plugins.title.color = textColor;
    
    // Update category chart if it exists
    if (window.categoryChart && typeof window.categoryChart.data !== 'undefined') {
      const chart = window.categoryChart;
      chart.data.datasets[0].backgroundColor = selectedColors.slice(0, chart.data.labels.length);
      chart.data.datasets[0].borderColor = selectedColors.map(color => color.replace('0.6', '1')).slice(0, chart.data.labels.length);
      
      // Update text color in options
      if (chart.options && chart.options.plugins && chart.options.plugins.legend) {
        chart.options.plugins.legend.labels.color = textColor;
        chart.options.plugins.legend.labels.font = {
          family: pixelFont,
          size: chart.options.plugins.legend.labels.font?.size || 12
        };
      }
      
      chart.update();
    }
    
    // Update vendor price chart colors
    if (window.vendorPriceChart && typeof window.vendorPriceChart.data !== 'undefined') {
      const chart = window.vendorPriceChart;
      
      // Update bar colors
      chart.data.datasets[0].backgroundColor = selectedColors.map(c => c);
      chart.data.datasets[0].borderColor = selectedColors.map(c => c.replace('0.6', '1'));
      
      // Update text colors
      if (chart.options && chart.options.plugins && chart.options.plugins.legend) {
        chart.options.plugins.legend.labels.color = textColor;
        chart.options.plugins.legend.labels.font = {
          family: pixelFont,
          size: chart.options.plugins.legend.labels.font?.size || 12
        };
      }
      
      // Update axis titles and ticks
      if (chart.options && chart.options.scales) {
        if (chart.options.scales.x) {
          chart.options.scales.x.ticks.color = textColor;
          chart.options.scales.x.ticks.font = {
            family: pixelFont,
            size: chart.options.scales.x.ticks.font?.size || 12
          };
          
          if (chart.options.scales.x.title) {
            chart.options.scales.x.title.color = textColor;
            chart.options.scales.x.title.font = {
              family: pixelFont,
              weight: chart.options.scales.x.title.font?.weight || 'bold',
              size: chart.options.scales.x.title.font?.size || 12
            };
          }
        }
        
        if (chart.options.scales.y) {
          chart.options.scales.y.ticks.color = textColor;
          chart.options.scales.y.ticks.font = {
            family: pixelFont,
            size: chart.options.scales.y.ticks.font?.size || 12
          };
          
          if (chart.options.scales.y.title) {
            chart.options.scales.y.title.color = textColor;
            chart.options.scales.y.title.font = {
              family: pixelFont,
              weight: chart.options.scales.y.title.font?.weight || 'bold',
              size: chart.options.scales.y.title.font?.size || 12
            };
          }
        }
      }
      
      chart.update();
    }
    
    // Update price vs rank chart colors
    if (window.priceRankChart && typeof window.priceRankChart.data !== 'undefined') {
      const chart = window.priceRankChart;
      
      // Update scatter plot colors
      if (chart.data && chart.data.datasets) {
        chart.data.datasets.forEach((dataset, i) => {
          const color = selectedColors[i % selectedColors.length];
          dataset.backgroundColor = color;
          dataset.borderColor = color.replace('0.6', '1');
        });
      }
      
      // Update text colors
      if (chart.options && chart.options.plugins && chart.options.plugins.legend) {
        chart.options.plugins.legend.labels.color = textColor;
        chart.options.plugins.legend.labels.font = {
          family: pixelFont,
          size: chart.options.plugins.legend.labels.font?.size || 12
        };
      }
      
      // Update axis titles and ticks
      if (chart.options && chart.options.scales) {
        if (chart.options.scales.x) {
          chart.options.scales.x.ticks.color = textColor;
          chart.options.scales.x.ticks.font = {
            family: pixelFont,
            size: chart.options.scales.x.ticks.font?.size || 12
          };
          
          if (chart.options.scales.x.title) {
            chart.options.scales.x.title.color = textColor;
            chart.options.scales.x.title.font = {
              family: pixelFont,
              weight: chart.options.scales.x.title.font?.weight || 'bold',
              size: chart.options.scales.x.title.font?.size || 12
            };
          }
        }
        
        if (chart.options.scales.y) {
          chart.options.scales.y.ticks.color = textColor;
          chart.options.scales.y.ticks.font = {
            family: pixelFont,
            size: chart.options.scales.y.ticks.font?.size || 12
          };
          
          if (chart.options.scales.y.title) {
            chart.options.scales.y.title.color = textColor;
            chart.options.scales.y.title.font = {
              family: pixelFont,
              weight: chart.options.scales.y.title.font?.weight || 'bold',
              size: chart.options.scales.y.title.font?.size || 12
            };
          }
        }
      }
      
      chart.update();
    }
  }
  
  // Update map colors
  function updateMapColors(color) {
    // Find all map line elements and update their color
    const mapLines = document.querySelectorAll('.leaflet-overlay-pane path');
    mapLines.forEach(line => {
      // Use style property instead of setAttribute for broader browser support
      line.style.stroke = color;
      
      // For polyline decorators (arrows)
      if (line.classList.contains('leaflet-polylineDecorator') || 
          !line.hasAttribute('stroke-dasharray')) {
        line.style.fill = color;
        line.style.fillOpacity = '0.8';
      }
    });
    
    // Check if we need to recreate the map with new colors for deeper changes
    if (window.teaMap) {
      // Store paths before recreating
      const origins = Object.keys(originData);
      origins.forEach(origin => {
        if (!origin || origin.trim() === '') return;
        
        // Try to find coordinates
        let coords;
        const originLower = origin.toLowerCase();
        
        for (const [key, value] of Object.entries(locationCoordinates)) {
          if (key.toLowerCase() === originLower) {
            coords = value;
            break;
          }
        }
        
        // Use fallback if needed
        if (!coords) {
          coords = [35.8617, 104.1954];
        }
        
        // Update line color if it exists
        const lines = document.querySelectorAll(`.leaflet-overlay-pane path`);
        lines.forEach(line => {
          if (!line.hasAttribute('stroke-dasharray')) return;
          line.style.stroke = color;
        });
      });
    }
  }
  
  // Event Listeners
  toggleCustomizePanel.addEventListener('click', () => {
    if (customizePanel.style.display === 'none') {
      customizePanel.style.display = 'block';
      toggleCustomizePanel.innerHTML = '<i class="bi bi-x-lg"></i> <span>Close</span>';
      toggleCustomizePanel.classList.add('active');
    } else {
      customizePanel.style.display = 'none';
      toggleCustomizePanel.innerHTML = '<i class="bi bi-palette"></i> <span>Customize</span>';
      toggleCustomizePanel.classList.remove('active');
    }
  });
  
  document.getElementById('saveCustomizations').addEventListener('click', () => {
    applyPreferences();
    savePreferences();
    
    // Close the customization panel automatically
    customizePanel.style.display = 'none';
    toggleCustomizePanel.innerHTML = '<i class="bi bi-palette"></i> <span>Customize</span>';
    toggleCustomizePanel.classList.remove('active');
  });
  
  document.getElementById('resetCustomizations').addEventListener('click', () => {
    // Reset form to defaults
    document.getElementById('themeDefault').checked = true;
    document.getElementById('categoryChartColors').value = 'default';
    document.getElementById('mapLineColor').value = '#ff637c';
    document.getElementById('chartTextColor').value = '#333333';
    document.getElementById('cardHeadersStyle').value = 'default';
    if (document.getElementById('dashboardTitleColor')) {
      document.getElementById('dashboardTitleColor').value = '#212529';
    }
    
    // Apply defaults
    applyPreferences();
    savePreferences();
  });
  
  // Apply changes in real-time for instant preview
  document.querySelectorAll('input[name="dashboardTheme"]').forEach(radio => {
    radio.addEventListener('change', applyPreferences);
  });
  
  document.getElementById('categoryChartColors').addEventListener('change', applyPreferences);
  document.getElementById('mapLineColor').addEventListener('change', applyPreferences);
  document.getElementById('chartTextColor').addEventListener('change', applyPreferences);
  document.getElementById('cardHeadersStyle').addEventListener('change', applyPreferences);
  if (document.getElementById('dashboardTitleColor')) {
    document.getElementById('dashboardTitleColor').addEventListener('change', applyPreferences);
  }
  
  // Load preferences on page load
  loadPreferences();
});
</script>

<!-- Sharing Modal -->
<div class="modal fade" id="shareModal" tabindex="-1" aria-labelledby="shareModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="shareModalLabel">Share</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="text-center mb-3">
          <div id="sharePreview" class="border rounded mb-3 mx-auto" style="max-width: 100%; overflow: hidden;">
            <!-- Preview content will be injected here -->
          </div>
          <div id="shareSpinner" class="text-center my-5 d-none">
            <div class="spinner-border text-primary" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2">Generating image...</p>
          </div>
        </div>
        <div class="share-options">
          <div class="d-grid gap-2">
            <button id="downloadImage" class="btn btn-primary">
              <i class="bi bi-download"></i> Download as Image
            </button>
            <button id="copyToClipboard" class="btn btn-secondary">
              <i class="bi bi-clipboard"></i> Copy to Clipboard
            </button>
            <button id="generateShareLink" class="btn btn-info">
              <i class="bi bi-link-45deg"></i> Generate Shareable Link
            </button>
            <div class="btn-group mt-2" role="group">
              <button id="shareTwitter" class="btn btn-outline-dark">
                <i class="bi bi-twitter"></i>
              </button>
              <button id="shareFacebook" class="btn btn-outline-dark">
                <i class="bi bi-facebook"></i>
              </button>
              <button id="shareReddit" class="btn btn-outline-dark">
                <i class="bi bi-reddit"></i>
              </button>
              <button id="shareWhatsApp" class="btn btn-outline-dark">
                <i class="bi bi-whatsapp"></i>
              </button>
            </div>
          </div>
        </div>
        <div id="shareLinkContainer" class="mt-3 d-none">
          <div class="input-group">
            <input type="text" id="shareLink" class="form-control" readonly>
            <button class="btn btn-outline-secondary" type="button" id="copyLinkBtn">Copy</button>
          </div>
          <small class="text-muted">This link will expire in 30 days</small>
        </div>
        <div id="shareResult" class="alert mt-3 d-none"></div>
      </div>
    </div>
  </div>
</div>

<!-- Load required libraries -->
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // Store references to chart elements
  const chartElements = {
    // Chart containers
    categoryChart: document.querySelector('.category-chart'),
    rankByCategory: document.querySelector('.card-header.bg-success')?.closest('.card'),
    worldMap: document.querySelector('.origins-map'),
    priceRankChart: document.querySelector('.price-rank-chart'),
    vendorPriceChart: document.querySelector('.vendor-price-chart')
  };
  
  let currentShareElement = null;
  let currentShareTitle = '';
  let capturedImage = null;
  
  // Add Bootstrap icons if not already included
  if (!document.querySelector('link[href*="bootstrap-icons"]')) {
    const iconLink = document.createElement('link');
    iconLink.rel = 'stylesheet';
    iconLink.href = 'https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css';
    document.head.appendChild(iconLink);
  }
  
  // Share chart button click handler
  document.querySelectorAll('.share-chart-btn').forEach(btn => {
    btn.addEventListener('click', function() {
      const chartId = this.dataset.chart;
      currentShareElement = chartElements[chartId] || document.getElementById(chartId);
      currentShareTitle = this.dataset.title;
      
      // Special handling for Chart.js charts
      if (chartId === 'categoryChart' && window.categoryChart) {
        currentShareElement = window.categoryChart.canvas;
      } else if (chartId === 'priceRankChart' && window.priceRankChart) {
        currentShareElement = window.priceRankChart.canvas;
      } else if (chartId === 'vendorPriceChart' && window.vendorPriceChart) {
        currentShareElement = window.vendorPriceChart.canvas;
      }
      
      console.log(`Sharing ${chartId}:`, currentShareElement);
      openShareModal();
    });
  });
  
  // Share Dashboard button click handler
  document.getElementById('shareDashboardBtn').addEventListener('click', function() {
    currentShareElement = document.querySelector('.container');
    currentShareTitle = 'Tea Analytics Dashboard';
    openShareModal();
  });
  
  // Open share modal and capture content
  function openShareModal() {
    // Check if Bootstrap 5 is available
    if (typeof bootstrap !== 'undefined') {
      const modalElement = document.getElementById('shareModal');
      const modal = new bootstrap.Modal(modalElement);
      modal.show();
    } else {
      // Fallback for Bootstrap 4 or jQuery
      $('#shareModal').modal('show');
    }
    
    // Slight delay to ensure the modal is rendered before capturing
    setTimeout(() => {
      captureContent();
    }, 300);
  }
  
  // Capture content as image using html2canvas
  function captureContent() {
    if (!currentShareElement) {
      console.error("No element selected for sharing");
      showShareResult('error', 'No content found to share. Please try again.');
      return;
    }
    
    console.log("Capturing element:", currentShareElement);
    
    const preview = document.getElementById('sharePreview');
    const spinner = document.getElementById('shareSpinner');
    
    // Clear previous content and show spinner
    preview.innerHTML = '';
    preview.style.display = 'none';
    spinner.classList.remove('d-none');
    
    try {
      // If it's a Chart.js canvas, we can just use that directly
      if (currentShareElement instanceof HTMLCanvasElement && 
          (currentShareElement.id === 'categoryChart' || 
           currentShareElement.id === 'priceRankChart' || 
           currentShareElement.id === 'vendorPriceChart')) {
        
        // Create a copy of the canvas with a white background
        const canvas = document.createElement('canvas');
        canvas.width = currentShareElement.width;
        canvas.height = currentShareElement.height;
        const ctx = canvas.getContext('2d');
        
        // Fill white background
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Copy the original canvas content
        ctx.drawImage(currentShareElement, 0, 0);
        
        // Add title text
        ctx.font = 'bold 16px Arial';
        ctx.fillStyle = '#333333';
        ctx.textAlign = 'center';
        ctx.fillText(currentShareTitle, canvas.width / 2, 30);
        
        // Add watermark
        ctx.font = '12px Arial';
        ctx.fillStyle = '#888888';
        ctx.textAlign = 'right';
        ctx.fillText('Generated with Tea Tracker', canvas.width - 10, canvas.height - 10);
        
        handleCapturedCanvas(canvas);
        return;
      }
      
      // For Leaflet map, special handling
      if (currentShareElement.id === 'worldMap' || 
          (currentShareElement.querySelector && currentShareElement.querySelector('#worldMap'))) {
        // Use map screenshot - leaflet has methods for this
        const mapContainer = document.getElementById('worldMap');
        if (mapContainer && window.map) {
          try {
            // Try to use leaflet-image if available
            if (window.leafletImage) {
              leafletImage(window.map, function(err, canvas) {
                if (err) {
                  console.error("Error capturing map:", err);
                  fallbackToHtml2Canvas();
                } else {
                  handleCapturedCanvas(canvas);
                }
              });
              return;
            } else {
              fallbackToHtml2Canvas();
            }
          } catch (err) {
            console.error("Error capturing map:", err);
            fallbackToHtml2Canvas();
          }
        } else {
          fallbackToHtml2Canvas();
        }
        return;
      }
      
      // For everything else, use html2canvas
      fallbackToHtml2Canvas();
    } catch (err) {
      console.error("Error in captureContent:", err);
      showShareResult('error', 'An unexpected error occurred. Please try again.');
      spinner.classList.add('d-none');
    }
    
    function fallbackToHtml2Canvas() {
      // Ensure element is visible
      const originalDisplay = currentShareElement.style.display;
      if (getComputedStyle(currentShareElement).display === 'none') {
        currentShareElement.style.display = 'block';
      }
      
      // Additional style options for better image quality
      const options = {
        scale: 2, // Increase for higher resolution
        useCORS: true,
        allowTaint: true,
        backgroundColor: '#ffffff',
        logging: true, // Enable logging for debugging
        onclone: function(clonedDoc) {
          try {
            // Add watermark to cloned element
            const watermark = clonedDoc.createElement('div');
            watermark.style.position = 'absolute';
            watermark.style.bottom = '10px';
            watermark.style.right = '10px';
            watermark.style.padding = '5px';
            watermark.style.borderRadius = '3px';
            watermark.style.backgroundColor = 'rgba(255,255,255,0.7)';
            watermark.style.fontSize = '12px';
            watermark.innerText = 'Generated with Tea Tracker';
            
            // Add title
            const title = clonedDoc.createElement('div');
            title.style.position = 'absolute';
            title.style.top = '10px';
            title.style.left = '10px';
            title.style.padding = '5px 10px';
            title.style.borderRadius = '3px';
            title.style.backgroundColor = 'rgba(255,255,255,0.9)';
            title.style.fontSize = '16px';
            title.style.fontWeight = 'bold';
            title.innerText = currentShareTitle;
            
            let clonedElement;
            
            // Try several methods to find the element
            if (currentShareElement.id) {
              clonedElement = clonedDoc.getElementById(currentShareElement.id);
            }
            
            if (!clonedElement && currentShareElement.className) {
              const classes = currentShareElement.className.split(' ');
              if (classes.length > 0) {
                clonedElement = clonedDoc.querySelector('.' + classes[0]);
              }
            }
            
            if (!clonedElement) {
              // If we can't find by ID or class, try to use a data attribute
              const uniqueId = 'share-target-' + Date.now();
              currentShareElement.setAttribute('data-share-id', uniqueId);
              clonedElement = clonedDoc.querySelector(`[data-share-id="${uniqueId}"]`);
            }
            
            if (clonedElement) {
              clonedElement.style.position = 'relative';
              clonedElement.style.overflow = 'visible';
              clonedElement.appendChild(watermark);
              clonedElement.appendChild(title);
            } else {
              console.error("Could not find cloned element");
            }
          } catch (err) {
            console.error("Error in onclone function:", err);
          }
        }
      };
      
      // Capture the element as an image
      html2canvas(currentShareElement, options)
        .then(canvas => {
          // Restore original display if needed
          if (originalDisplay !== currentShareElement.style.display) {
            currentShareElement.style.display = originalDisplay;
          }
          
          handleCapturedCanvas(canvas);
        })
        .catch(err => {
          console.error("Error capturing content:", err);
          showShareResult('error', 'Failed to generate image. Please try again.');
          spinner.classList.add('d-none');
          
          // Restore original display if needed
          if (originalDisplay !== currentShareElement.style.display) {
            currentShareElement.style.display = originalDisplay;
          }
        });
    }
  }
  
  function handleCapturedCanvas(canvas) {
    const preview = document.getElementById('sharePreview');
    const spinner = document.getElementById('shareSpinner');
    
    capturedImage = canvas;
    
    // Set max dimensions while maintaining aspect ratio
    const maxWidth = preview.offsetWidth;
    const scale = maxWidth / canvas.width;
    const scaledHeight = canvas.height * scale;
    
    // Resize canvas for preview
    canvas.style.width = '100%';
    canvas.style.height = 'auto';
    canvas.style.borderRadius = '4px';
    
    // Hide spinner and show preview
    spinner.classList.add('d-none');
    preview.style.display = 'block';
    preview.appendChild(canvas);
    
    // Enable share buttons now that we have an image
    enableShareButtons();
  }
  
  // Enable share buttons once image is generated
  function enableShareButtons() {
    document.getElementById('downloadImage').disabled = false;
    document.getElementById('copyToClipboard').disabled = false;
    document.getElementById('generateShareLink').disabled = false;
    document.getElementById('shareTwitter').disabled = false;
    document.getElementById('shareFacebook').disabled = false;
    document.getElementById('shareReddit').disabled = false;
    document.getElementById('shareWhatsApp').disabled = false;
  }
  
  // Download Image button click handler
  document.getElementById('downloadImage').addEventListener('click', function() {
    if (!capturedImage) return;
    
    capturedImage.toBlob(function(blob) {
      saveAs(blob, `${currentShareTitle.replace(/\s+/g, '_')}.png`);
      showShareResult('success', 'Image downloaded successfully!');
    });
  });
  
  // Copy to Clipboard button click handler
  document.getElementById('copyToClipboard').addEventListener('click', async function() {
    if (!capturedImage) return;
    
    try {
      const blob = await new Promise(resolve => capturedImage.toBlob(resolve));
      await navigator.clipboard.write([
        new ClipboardItem({
          [blob.type]: blob
        })
      ]);
      showShareResult('success', 'Image copied to clipboard!');
    } catch (err) {
      console.error('Failed to copy image: ', err);
      showShareResult('error', 'Failed to copy image. Your browser may not support this feature.');
    }
  });
  
  // Generate Share Link button click handler
  document.getElementById('generateShareLink').addEventListener('click', async function() {
    if (!capturedImage) return;
    
    try {
      const linkContainer = document.getElementById('shareLinkContainer');
      const linkInput = document.getElementById('shareLink');
      
      showShareResult('info', 'Generating shareable link...');
      
      // Convert canvas to blob and upload to a service
      // This would typically call your backend API to handle storage
      // For demo purposes, we'll just simulate it with a timeout
      
      setTimeout(() => {
        // Replace with your actual API call that returns a shareable link
        const demoShareLink = `${window.location.origin}/share/${Math.random().toString(36).substring(2, 10)}`;
        
        linkInput.value = demoShareLink;
        linkContainer.classList.remove('d-none');
        
        showShareResult('success', 'Shareable link generated!');
      }, 1000);
    } catch (err) {
      console.error('Failed to generate link: ', err);
      showShareResult('error', 'Failed to generate shareable link.');
    }
  });
  
  // Copy Share Link button handler
  document.getElementById('copyLinkBtn').addEventListener('click', function() {
    const linkInput = document.getElementById('shareLink');
    linkInput.select();
    document.execCommand('copy');
    
    this.innerText = 'Copied!';
    setTimeout(() => {
      this.innerText = 'Copy';
    }, 2000);
  });
  
  // Social media share handlers
  document.getElementById('shareTwitter').addEventListener('click', function() {
    shareToSocialMedia('twitter');
  });
  
  document.getElementById('shareFacebook').addEventListener('click', function() {
    shareToSocialMedia('facebook');
  });
  
  document.getElementById('shareReddit').addEventListener('click', function() {
    shareToSocialMedia('reddit');
  });
  
  document.getElementById('shareWhatsApp').addEventListener('click', function() {
    shareToSocialMedia('whatsapp');
  });
  
  // Share to social media platforms
  function shareToSocialMedia(platform) {
    // In a real implementation, you would:
    // 1. Create a shareable link to your image
    // 2. Construct the appropriate social media share URL
    
    // For demo purposes, we'll check if Web Share API is available
    if (navigator.share && capturedImage) {
      capturedImage.toBlob(async function(blob) {
        const file = new File([blob], `${currentShareTitle.replace(/\s+/g, '_')}.png`, { type: 'image/png' });
        
        try {
          await navigator.share({
            title: currentShareTitle,
            text: 'Check out my Tea Tracker stats!',
            files: [file]
          });
          showShareResult('success', 'Content shared successfully!');
        } catch (err) {
          console.error('Error sharing:', err);
          
          // Fallback to platform-specific sharing
          let shareUrl = '';
          
          // This would be replaced with your actual shareable link in production
          const demoShareLink = `${window.location.origin}/share/${Math.random().toString(36).substring(2, 10)}`;
          
          switch (platform) {
            case 'twitter':
              shareUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(currentShareTitle)}&url=${encodeURIComponent(demoShareLink)}`;
              break;
            case 'facebook':
              shareUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(demoShareLink)}`;
              break;
            case 'reddit':
              shareUrl = `https://www.reddit.com/submit?url=${encodeURIComponent(demoShareLink)}&title=${encodeURIComponent(currentShareTitle)}`;
              break;
            case 'whatsapp':
              shareUrl = `https://api.whatsapp.com/send?text=${encodeURIComponent(currentShareTitle + ' ' + demoShareLink)}`;
              break;
          }
          
          if (shareUrl) {
            window.open(shareUrl, '_blank');
          }
        }
      });
    } else {
      // Fallback for browsers that don't support Web Share API
      showShareResult('info', 'Direct sharing not supported in your browser. Please use the "Generate Shareable Link" option instead.');
    }
  }
  
  // Display result messages
  function showShareResult(type, message) {
    const resultElement = document.getElementById('shareResult');
    
    resultElement.className = 'alert mt-3';
    resultElement.classList.add(`alert-${type === 'error' ? 'danger' : type}`);
    resultElement.textContent = message;
    resultElement.classList.remove('d-none');
    
    setTimeout(() => {
      resultElement.classList.add('d-none');
    }, 5000);
  }
});
</script>